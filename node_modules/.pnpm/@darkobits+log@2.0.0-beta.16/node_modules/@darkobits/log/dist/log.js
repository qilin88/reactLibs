"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = LogFactory;

var _os = _interopRequireDefault(require("os"));

var _util = _interopRequireDefault(require("util"));

var _stream = require("stream");

var _env2 = _interopRequireDefault(require("@darkobits/env"));

var _maskString = _interopRequireDefault(require("@darkobits/mask-string"));

var _sleep = _interopRequireDefault(require("@darkobits/sleep"));

var _stripIndent = _interopRequireDefault(require("strip-indent"));

var _chalk = _interopRequireDefault(require("chalk"));

var _callsiteRecord = _interopRequireDefault(require("callsite-record"));

var dateFns = _interopRequireWildcard(require("date-fns"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _isCi = _interopRequireDefault(require("is-ci"));

var _isPlainObject = require("is-plain-object");

var _ow = _interopRequireDefault(require("ow"));

var _sourceMapSupport = _interopRequireDefault(require("source-map-support"));

var _config = _interopRequireWildcard(require("./etc/config"));

var _style = _interopRequireDefault(require("./etc/style"));

var _constants = require("./etc/constants");

var _utils = require("./lib/utils");

var _history = _interopRequireDefault(require("./lib/history"));

var _isDebugNamespace = _interopRequireDefault(require("./lib/is-debug-namespace"));

var _logPipe = _interopRequireDefault(require("./lib/log-pipe"));

var _progressBar = _interopRequireDefault(require("./lib/progress-bar"));

var _spinner = _interopRequireDefault(require("./lib/spinner"));

var _timer = _interopRequireDefault(require("./lib/timer"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LogFactory(userOptions = {}) {
  const log = (0, _utils.createOrphanedObject)();
  let options = (0, _deepmerge.default)(_config.default, _style.default);
  const secrets = [];
  let stream;
  let history;

  const maskSecretsInLine = line => {
    return secrets.reduce((messageAccumulator, [curSecret, curMaskChar]) => {
      return (0, _maskString.default)(String(curSecret), messageAccumulator, curMaskChar);
    }, line);
  };

  const outputLogLine = logLine => {
    history.write(maskSecretsInLine(`${logLine}${_os.default.EOL}`));
  };

  const styleToken = (token, styleFn) => {
    if (token === undefined) {
      return;
    }

    if (typeof styleFn !== 'function') {
      return token;
    }

    return styleFn(token, log.chalk);
  };

  const formatLogArgument = arg => {
    if (typeof arg === 'string') {
      if (options.stripIndent) {
        return (0, _stripIndent.default)(arg).trim();
      }

      return arg;
    }

    if (arg instanceof Error) {
      return (0, _utils.formatError)(log.chalk, arg);
    }

    return _util.default.inspect(arg, {
      colors: true,
      depth: 20
    });
  };

  const convertArgumentsToLines = (level, ...args) => {
    const {
      heading,
      levels,
      style,
      timestamp
    } = options;
    (0, _ow.default)(levels, 'levels', _ow.default.object.plain);
    (0, _ow.default)(style, 'style', _ow.default.object.plain);
    let prefix = '';
    const lines = args.map(arg => {
      if (arg !== null && arg !== void 0 && arg[_constants.IS_PREFIX]) {
        prefix = arg;
        return false;
      }

      return formatLogArgument(arg);
    }).filter(Boolean).join(' ').split(_os.default.EOL);
    const lead = [timestamp ? styleToken(dateFns.format(new Date(), timestamp), style.timestamp) : false, styleToken(heading, style.heading), styleToken(levels[level].label, levels[level].style), prefix].filter(Boolean).join(' ');
    return lines.map(line => `${lead} ${line}`);
  };

  const handleLogArguments = (level, ...args) => {
    if (!log.isLevelAtLeast(level)) {
      return;
    }

    convertArgumentsToLines(level, ...args).forEach(logLine => {
      outputLogLine(logLine);
    });
  };

  const addLevel = (name, levelOptions) => {
    (0, _ow.default)(levelOptions.label, 'label', _ow.default.string);
    (0, _ow.default)(levelOptions.level, 'level', _ow.default.number);

    if (name === 'silent') {
      return;
    }

    Reflect.set(log, name, (...args) => {
      handleLogArguments(name, ...args);
    });
  };

  const handleInteractiveWrite = (sessionId, messageFn) => {
    history.doInteractiveWrite(sessionId, messageFn);
  };

  log.getLevel = () => {
    const {
      level,
      levels
    } = options;
    return { ...levels[level]
    };
  };

  log.getLevels = () => {
    const {
      levels
    } = options;
    return levels;
  };

  log.isLevelAtLeast = name => {
    const {
      levels
    } = options;
    const testLevel = levels[name];

    if (!testLevel) {
      throw new Error(`Invalid log level: "${name}".`);
    }

    return log.getLevel().level >= testLevel.level;
  };

  log.configure = (newOptions = {}) => {
    const streamFromOptions = Reflect.get(newOptions, 'stream');
    Reflect.deleteProperty(newOptions, 'stream');

    if (streamFromOptions !== undefined) {
      stream = streamFromOptions;
    } else if (stream === undefined) {
      stream = _config.DEFAULT_STREAM;
    }

    options = (0, _deepmerge.default)(options, newOptions, {
      isMergeableObject: _isPlainObject.isPlainObject
    });
    (0, _ow.default)(stream, 'stream', _ow.default.any(_ow.default.undefined, _ow.default.object.instanceOf(_stream.Writable), _ow.default.boolean.false));
    (0, _ow.default)(options.levels, 'levels', _ow.default.object.plain);

    if (options.heading && (0, _isDebugNamespace.default)(options.heading)) {
      options.level = 'silly';
    } else {
      var _ref, _env;

      options.level = (_ref = (_env = (0, _env2.default)('LOG_LEVEL')) !== null && _env !== void 0 ? _env : options.level) !== null && _ref !== void 0 ? _ref : 'info';
    }

    if (!log.chalk) {
      log.chalk = new _chalk.default.Instance(options.chalk);
    }

    if (!history) {
      history = (0, _history.default)({
        stream
      });
    } else {
      history.setStream(stream);
    }

    Object.entries(options.levels).forEach(([name, descriptor]) => {
      if (!Reflect.has(log, name)) {
        addLevel(name, (0, _deepmerge.default)(_constants.DEFAULT_LEVEL_OPTIONS, descriptor || {}));
      }
    });
  };

  log.prefix = prefix => {
    let formattedPrefix = prefix;
    const {
      style
    } = options;

    if (style.prefix) {
      var _styleToken;

      formattedPrefix = (_styleToken = styleToken(prefix, style.prefix)) !== null && _styleToken !== void 0 ? _styleToken : prefix;
    }

    return {
      [_constants.IS_PREFIX]: true,
      toString: () => formattedPrefix.toString()
    };
  };

  log.beginInteractive = userInteractiveOptions => {
    const interactiveOptions = typeof userInteractiveOptions === 'function' ? {
      message: userInteractiveOptions,
      interval: _constants.DEFAULT_FRAME_RATE
    } : (0, _deepmerge.default)({
      interval: _constants.DEFAULT_FRAME_RATE
    }, userInteractiveOptions);
    const sessionId = history.beginInteractiveSession();

    const endInteractiveSession = userStopOptions => {
      let stopOptions = {};

      if (typeof userStopOptions === 'function') {
        stopOptions = {
          message: userStopOptions
        };
      } else if (userStopOptions) {
        stopOptions = userStopOptions;
      }

      if (_isCi.default && typeof stopOptions.message === 'function') {
        stopOptions.message();
        return;
      }

      if (stopOptions && typeof stopOptions.message === 'function') {
        handleInteractiveWrite(sessionId, stopOptions.message);
      }

      history.endInteractiveSession(sessionId);
    };

    if (_isCi.default) {
      interactiveOptions.message();
      return endInteractiveSession;
    }

    (0, _ow.default)(interactiveOptions.message, 'message', _ow.default.function);
    (0, _ow.default)(interactiveOptions.interval, 'interval', _ow.default.number.positive);

    const interactiveLoop = async () => {
      while (history.hasInteractiveSession(sessionId)) {
        handleInteractiveWrite(sessionId, interactiveOptions.message);
        await (0, _sleep.default)(interactiveOptions.interval);
      }
    };

    void interactiveLoop();
    return endInteractiveSession;
  };

  log.addSecret = (secret, maskChar = '*') => {
    (0, _ow.default)(secret, 'secret', _ow.default.any(_ow.default.string, _ow.default.number, _ow.default.boolean, _ow.default.regExp));
    (0, _ow.default)(maskChar, 'mask character', _ow.default.string.minLength(1).maxLength(1));
    secrets.push([secret, maskChar]);
  };

  log.createPipe = level => {
    if (!Object.keys(log.getLevels()).includes(level)) {
      throw new Error(`Invalid log level: ${level}`);
    }

    return new _logPipe.default(log[level]);
  };

  log.codeFrame = err => {
    const callsiteRecord = (0, _callsiteRecord.default)({
      forError: err,
      processFrameFn: frame => {
        Reflect.defineProperty(frame, 'isNative', {
          value: () => false
        });
        return _sourceMapSupport.default.wrapCallSite(frame);
      }
    });

    if (!callsiteRecord) {
      throw new Error(`Unable to produce a call site record for error: "${err.message}"`);
    }

    return callsiteRecord.renderSync({
      stack: false
    });
  };

  log.createTimer = _timer.default;
  log.createProgressBar = _progressBar.default;
  log.createSpinner = _spinner.default;
  log.configure(userOptions);
  return log;
}

module.exports = exports.default;
//# sourceMappingURL=log.js.map