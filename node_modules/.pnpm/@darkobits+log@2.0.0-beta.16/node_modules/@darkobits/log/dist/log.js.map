{"version":3,"sources":["../src/log.ts"],"names":["LogFactory","userOptions","log","options","DEFAULT_CONFIG","DEFAULT_STYLE","secrets","stream","history","maskSecretsInLine","line","reduce","messageAccumulator","curSecret","curMaskChar","String","outputLogLine","logLine","write","os","EOL","styleToken","token","styleFn","undefined","chalk","formatLogArgument","arg","stripIndent","trim","Error","util","inspect","colors","depth","convertArgumentsToLines","level","args","heading","levels","style","timestamp","ow","object","plain","prefix","lines","map","IS_PREFIX","filter","Boolean","join","split","lead","dateFns","format","Date","label","handleLogArguments","isLevelAtLeast","forEach","addLevel","name","levelOptions","string","number","Reflect","set","handleInteractiveWrite","sessionId","messageFn","doInteractiveWrite","getLevel","getLevels","testLevel","configure","newOptions","streamFromOptions","get","deleteProperty","DEFAULT_STREAM","isMergeableObject","isPlainObject","any","instanceOf","Writable","boolean","false","Instance","setStream","Object","entries","descriptor","has","DEFAULT_LEVEL_OPTIONS","formattedPrefix","toString","beginInteractive","userInteractiveOptions","interactiveOptions","message","interval","DEFAULT_FRAME_RATE","beginInteractiveSession","endInteractiveSession","userStopOptions","stopOptions","IS_CI","function","positive","interactiveLoop","hasInteractiveSession","addSecret","secret","maskChar","regExp","minLength","maxLength","push","createPipe","keys","includes","LogPipe","codeFrame","err","callsiteRecord","forError","processFrameFn","frame","defineProperty","value","sourceMapSupport","wrapCallSite","renderSync","stack","createTimer","TimerFactory","createProgressBar","ProgressBarFactory","createSpinner","SpinnerFactory"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AAeA;;AAIA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAMe,SAASA,UAAT,CAAoBC,WAAgC,GAAG,EAAvD,EAA2D;AAIxE,QAAMC,GAAG,GAAG,kCAAZ;AAQA,MAAIC,OAAO,GAAG,wBAA4CC,eAA5C,EAA4DC,cAA5D,CAAd;AAQA,QAAMC,OAA4C,GAAG,EAArD;AASA,MAAIC,MAAJ;AAQA,MAAIC,OAAJ;;AAWA,QAAMC,iBAAiB,GAAIC,IAAD,IAAkB;AAC1C,WAAOJ,OAAO,CAACK,MAAR,CAAuB,CAACC,kBAAD,EAAqB,CAACC,SAAD,EAAYC,WAAZ,CAArB,KAAkD;AAC9E,aAAO,yBAAKC,MAAM,CAACF,SAAD,CAAX,EAAwBD,kBAAxB,EAA4CE,WAA5C,CAAP;AACD,KAFM,EAEJJ,IAFI,CAAP;AAGD,GAJD;;AAaA,QAAMM,aAAa,GAAIC,OAAD,IAAqB;AACzCT,IAAAA,OAAO,CAACU,KAAR,CAAcT,iBAAiB,CAAE,GAAEQ,OAAQ,GAAEE,YAAGC,GAAI,EAArB,CAA/B;AACD,GAFD;;AAWA,QAAMC,UAAU,GAAG,CAACC,KAAD,EAA+BC,OAA/B,KAAsE;AACvF,QAAID,KAAK,KAAKE,SAAd,EAAyB;AACvB;AACD;;AAED,QAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;AACjC,aAAOD,KAAP;AACD;;AAED,WAAOC,OAAO,CAACD,KAAD,EAAkBpB,GAAG,CAACuB,KAAtB,CAAd;AACD,GAVD;;AAmBA,QAAMC,iBAAiB,GAAIC,GAAD,IAAc;AAEtC,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAIxB,OAAO,CAACyB,WAAZ,EAAyB;AACvB,eAAO,0BAAYD,GAAZ,EAAiBE,IAAjB,EAAP;AACD;;AAED,aAAOF,GAAP;AACD;;AAGD,QAAIA,GAAG,YAAYG,KAAnB,EAA0B;AACxB,aAAO,wBAAY5B,GAAG,CAACuB,KAAhB,EAAuBE,GAAvB,CAAP;AACD;;AAGD,WAAOI,cAAKC,OAAL,CAAaL,GAAb,EAAkB;AAACM,MAAAA,MAAM,EAAE,IAAT;AAAeC,MAAAA,KAAK,EAAE;AAAtB,KAAlB,CAAP;AACD,GAjBD;;AA8BA,QAAMC,uBAAuB,GAAG,CAACC,KAAD,EAAgB,GAAGC,IAAnB,KAAwC;AACtE,UAAM;AAACC,MAAAA,OAAD;AAAUC,MAAAA,MAAV;AAAkBC,MAAAA,KAAlB;AAAyBC,MAAAA;AAAzB,QAAsCtC,OAA5C;AAEA,qBAAGoC,MAAH,EAAW,QAAX,EAAqBG,YAAGC,MAAH,CAAUC,KAA/B;AACA,qBAAGJ,KAAH,EAAU,OAAV,EAAmBE,YAAGC,MAAH,CAAUC,KAA7B;AAEA,QAAIC,MAAM,GAAG,EAAb;AAEA,UAAMC,KAAK,GAAGT,IAAI,CAACU,GAAL,CAASpB,GAAG,IAAI;AAG5B,UAAIA,GAAJ,aAAIA,GAAJ,eAAIA,GAAG,CAAGqB,oBAAH,CAAP,EAAsB;AACpBH,QAAAA,MAAM,GAAGlB,GAAT;AACA,eAAO,KAAP;AACD;;AAED,aAAOD,iBAAiB,CAACC,GAAD,CAAxB;AACD,KATa,EASXsB,MATW,CASJC,OATI,EASKC,IATL,CASU,GATV,EASeC,KATf,CASqBjC,YAAGC,GATxB,CAAd;AAYA,UAAMiC,IAAI,GAAG,CAEXZ,SAAS,GAAGpB,UAAU,CAACiC,OAAO,CAACC,MAAR,CAAe,IAAIC,IAAJ,EAAf,EAA2Bf,SAA3B,CAAD,EAAwCD,KAAK,CAACC,SAA9C,CAAb,GAAwE,KAFtE,EAIXpB,UAAU,CAACiB,OAAD,EAAUE,KAAK,CAACF,OAAhB,CAJC,EAMXjB,UAAU,CAACkB,MAAM,CAACH,KAAD,CAAN,CAAcqB,KAAf,EAAsBlB,MAAM,CAACH,KAAD,CAAN,CAAcI,KAApC,CANC,EAQXK,MARW,EASXI,MATW,CASJC,OATI,EASKC,IATL,CASU,GATV,CAAb;AAYA,WAAOL,KAAK,CAACC,GAAN,CAAUrC,IAAI,IAAK,GAAE2C,IAAK,IAAG3C,IAAK,EAAlC,CAAP;AACD,GAjCD;;AA0CA,QAAMgD,kBAAkB,GAAG,CAACtB,KAAD,EAAgB,GAAGC,IAAnB,KAAwC;AAGjE,QAAI,CAACnC,GAAG,CAACyD,cAAJ,CAAmBvB,KAAnB,CAAL,EAAgC;AAC9B;AACD;;AAGDD,IAAAA,uBAAuB,CAACC,KAAD,EAAQ,GAAGC,IAAX,CAAvB,CAAwCuB,OAAxC,CAAgD3C,OAAO,IAAI;AAIzDD,MAAAA,aAAa,CAACC,OAAD,CAAb;AACD,KALD;AAMD,GAdD;;AAsBA,QAAM4C,QAAQ,GAAG,CAACC,IAAD,EAAeC,YAAf,KAAiD;AAChE,qBAAGA,YAAY,CAACN,KAAhB,EAAuB,OAAvB,EAAgCf,YAAGsB,MAAnC;AACA,qBAAGD,YAAY,CAAC3B,KAAhB,EAAuB,OAAvB,EAAgCM,YAAGuB,MAAnC;;AAIA,QAAIH,IAAI,KAAK,QAAb,EAAuB;AACrB;AACD;;AAGDI,IAAAA,OAAO,CAACC,GAAR,CAAYjE,GAAZ,EAAiB4D,IAAjB,EAAuB,CAAC,GAAGzB,IAAJ,KAAyB;AAC9CqB,MAAAA,kBAAkB,CAACI,IAAD,EAAO,GAAGzB,IAAV,CAAlB;AACD,KAFD;AAGD,GAdD;;AAuBA,QAAM+B,sBAAsB,GAAG,CAACC,SAAD,EAAoBC,SAApB,KAAuC;AACpE9D,IAAAA,OAAO,CAAC+D,kBAAR,CAA2BF,SAA3B,EAAsCC,SAAtC;AACD,GAFD;;AAcApE,EAAAA,GAAG,CAACsE,QAAJ,GAAe,MAAM;AACnB,UAAM;AAACpC,MAAAA,KAAD;AAAQG,MAAAA;AAAR,QAAkBpC,OAAxB;AACA,WAAO,EAAC,GAAGoC,MAAM,CAACH,KAAD;AAAV,KAAP;AACD,GAHD;;AAMAlC,EAAAA,GAAG,CAACuE,SAAJ,GAAgB,MAAM;AACpB,UAAM;AAAClC,MAAAA;AAAD,QAAWpC,OAAjB;AAEA,WAAOoC,MAAP;AAGD,GAND;;AASArC,EAAAA,GAAG,CAACyD,cAAJ,GAAqBG,IAAI,IAAI;AAC3B,UAAM;AAACvB,MAAAA;AAAD,QAAWpC,OAAjB;AAEA,UAAMuE,SAAS,GAAGnC,MAAM,CAACuB,IAAD,CAAxB;;AAEA,QAAI,CAACY,SAAL,EAAgB;AACd,YAAM,IAAI5C,KAAJ,CAAW,uBAAsBgC,IAAK,IAAtC,CAAN;AACD;;AAED,WAAO5D,GAAG,CAACsE,QAAJ,GAAepC,KAAf,IAAwBsC,SAAS,CAACtC,KAAzC;AACD,GAVD;;AAaAlC,EAAAA,GAAG,CAACyE,SAAJ,GAAgB,CAACC,UAAU,GAAG,EAAd,KAAqB;AAGnC,UAAMC,iBAA4D,GAAGX,OAAO,CAACY,GAAR,CAAYF,UAAZ,EAAwB,QAAxB,CAArE;AACAV,IAAAA,OAAO,CAACa,cAAR,CAAuBH,UAAvB,EAAmC,QAAnC;;AAEA,QAAIC,iBAAiB,KAAKrD,SAA1B,EAAqC;AAEnCjB,MAAAA,MAAM,GAAGsE,iBAAT;AACD,KAHD,MAGO,IAAItE,MAAM,KAAKiB,SAAf,EAA0B;AAG/BjB,MAAAA,MAAM,GAAGyE,sBAAT;AACD;;AAED7E,IAAAA,OAAO,GAAG,wBAA4CA,OAA5C,EAAqDyE,UAArD,EAAiE;AACzEK,MAAAA,iBAAiB,EAAEC;AADsD,KAAjE,CAAV;AAIA,qBAAG3E,MAAH,EAAW,QAAX,EAAqBmC,YAAGyC,GAAH,CAAOzC,YAAGlB,SAAV,EAAqBkB,YAAGC,MAAH,CAAUyC,UAAV,CAAqBC,gBAArB,CAArB,EAAqD3C,YAAG4C,OAAH,CAAWC,KAAhE,CAArB;AACA,qBAAGpF,OAAO,CAACoC,MAAX,EAAmB,QAAnB,EAA6BG,YAAGC,MAAH,CAAUC,KAAvC;;AAGA,QAAIzC,OAAO,CAACmC,OAAR,IAAmB,+BAAiBnC,OAAO,CAACmC,OAAzB,CAAvB,EAA0D;AACxDnC,MAAAA,OAAO,CAACiC,KAAR,GAAgB,OAAhB;AACD,KAFD,MAEO;AAAA;;AACLjC,MAAAA,OAAO,CAACiC,KAAR,mBAAgB,mBAAI,WAAJ,CAAhB,uCAAoCjC,OAAO,CAACiC,KAA5C,uCAAqD,MAArD;AACD;;AAED,QAAI,CAAClC,GAAG,CAACuB,KAAT,EAAgB;AAGdvB,MAAAA,GAAG,CAACuB,KAAJ,GAAY,IAAIA,eAAM+D,QAAV,CAAmBrF,OAAO,CAACsB,KAA3B,CAAZ;AACD;;AAED,QAAI,CAACjB,OAAL,EAAc;AAEZA,MAAAA,OAAO,GAAG,sBAAkB;AAACD,QAAAA;AAAD,OAAlB,CAAV;AACD,KAHD,MAGO;AAELC,MAAAA,OAAO,CAACiF,SAAR,CAAkBlF,MAAlB;AACD;;AAGDmF,IAAAA,MAAM,CAACC,OAAP,CAAexF,OAAO,CAACoC,MAAvB,EAA+BqB,OAA/B,CAAuC,CAAC,CAACE,IAAD,EAAO8B,UAAP,CAAD,KAAwB;AAC7D,UAAI,CAAC1B,OAAO,CAAC2B,GAAR,CAAY3F,GAAZ,EAAiB4D,IAAjB,CAAL,EAA6B;AAC3BD,QAAAA,QAAQ,CAACC,IAAD,EAAO,wBAAMgC,gCAAN,EAA6BF,UAAU,IAAI,EAA3C,CAAP,CAAR;AACD;AACF,KAJD;AAKD,GAjDD;;AAoDA1F,EAAAA,GAAG,CAAC2C,MAAJ,GAAaA,MAAM,IAAI;AACrB,QAAIkD,eAAe,GAAGlD,MAAtB;AACA,UAAM;AAACL,MAAAA;AAAD,QAAUrC,OAAhB;;AAEA,QAAIqC,KAAK,CAACK,MAAV,EAAkB;AAAA;;AAChBkD,MAAAA,eAAe,kBAAG1E,UAAU,CAACwB,MAAD,EAASL,KAAK,CAACK,MAAf,CAAb,qDAAuCA,MAAtD;AACD;;AAED,WAAO;AACL,OAACG,oBAAD,GAAa,IADR;AAELgD,MAAAA,QAAQ,EAAE,MAAMD,eAAe,CAACC,QAAhB;AAFX,KAAP;AAID,GAZD;;AAeA9F,EAAAA,GAAG,CAAC+F,gBAAJ,GAAuBC,sBAAsB,IAAI;AAC/C,UAAMC,kBAAqD,GAAG,OAAOD,sBAAP,KAAkC,UAAlC,GAC1D;AAAEE,MAAAA,OAAO,EAAEF,sBAAX;AAAmCG,MAAAA,QAAQ,EAAEC;AAA7C,KAD0D,GAE1D,wBACA;AAAED,MAAAA,QAAQ,EAAEC;AAAZ,KADA,EAEAJ,sBAFA,CAFJ;AAOA,UAAM7B,SAAS,GAAG7D,OAAO,CAAC+F,uBAAR,EAAlB;;AAEA,UAAMC,qBAAuC,GAAGC,eAAe,IAAI;AACjE,UAAIC,WAA2C,GAAG,EAAlD;;AAGA,UAAI,OAAOD,eAAP,KAA2B,UAA/B,EAA2C;AACzCC,QAAAA,WAAW,GAAG;AACZN,UAAAA,OAAO,EAAEK;AADG,SAAd;AAGD,OAJD,MAIO,IAAIA,eAAJ,EAAqB;AAC1BC,QAAAA,WAAW,GAAGD,eAAd;AACD;;AAID,UAAIE,iBAAS,OAAOD,WAAW,CAACN,OAAnB,KAA+B,UAA5C,EAAwD;AACtDM,QAAAA,WAAW,CAACN,OAAZ;AACA;AACD;;AAED,UAAIM,WAAW,IAAI,OAAOA,WAAW,CAACN,OAAnB,KAA+B,UAAlD,EAA8D;AAC5DhC,QAAAA,sBAAsB,CAACC,SAAD,EAAYqC,WAAW,CAACN,OAAxB,CAAtB;AACD;;AAED5F,MAAAA,OAAO,CAACgG,qBAAR,CAA8BnC,SAA9B;AACD,KAxBD;;AA4BA,QAAIsC,aAAJ,EAAW;AACTR,MAAAA,kBAAkB,CAACC,OAAnB;AACA,aAAOI,qBAAP;AACD;;AAED,qBAAGL,kBAAkB,CAACC,OAAtB,EAA+B,SAA/B,EAA0C1D,YAAGkE,QAA7C;AACA,qBAAGT,kBAAkB,CAACE,QAAtB,EAAgC,UAAhC,EAA4C3D,YAAGuB,MAAH,CAAU4C,QAAtD;;AAEA,UAAMC,eAAe,GAAG,YAAY;AAClC,aAAOtG,OAAO,CAACuG,qBAAR,CAA8B1C,SAA9B,CAAP,EAAiD;AAC/CD,QAAAA,sBAAsB,CAACC,SAAD,EAAY8B,kBAAkB,CAACC,OAA/B,CAAtB;AACA,cAAM,oBAAMD,kBAAkB,CAACE,QAAzB,CAAN;AACD;AACF,KALD;;AAOA,SAAKS,eAAe,EAApB;AAEA,WAAON,qBAAP;AACD,GAxDD;;AA2DAtG,EAAAA,GAAG,CAAC8G,SAAJ,GAAgB,CAACC,MAAD,EAASC,QAAQ,GAAG,GAApB,KAA4B;AAC1C,qBAAGD,MAAH,EAAW,QAAX,EAAqBvE,YAAGyC,GAAH,CAAOzC,YAAGsB,MAAV,EAAkBtB,YAAGuB,MAArB,EAA6BvB,YAAG4C,OAAhC,EAAyC5C,YAAGyE,MAA5C,CAArB;AACA,qBAAGD,QAAH,EAAa,gBAAb,EAA+BxE,YAAGsB,MAAH,CAAUoD,SAAV,CAAoB,CAApB,EAAuBC,SAAvB,CAAiC,CAAjC,CAA/B;AACA/G,IAAAA,OAAO,CAACgH,IAAR,CAAa,CAACL,MAAD,EAASC,QAAT,CAAb;AACD,GAJD;;AAOAhH,EAAAA,GAAG,CAACqH,UAAJ,GAAiBnF,KAAK,IAAI;AAExB,QAAI,CAACsD,MAAM,CAAC8B,IAAP,CAAYtH,GAAG,CAACuE,SAAJ,EAAZ,EAA6BgD,QAA7B,CAAsCrF,KAAtC,CAAL,EAAmD;AACjD,YAAM,IAAIN,KAAJ,CAAW,sBAAqBM,KAAM,EAAtC,CAAN;AACD;;AAGD,WAAO,IAAIsF,gBAAJ,CAAYxH,GAAG,CAACkC,KAAD,CAAf,CAAP;AACD,GARD;;AAWAlC,EAAAA,GAAG,CAACyH,SAAJ,GAAgBC,GAAG,IAAI;AACrB,UAAMC,cAAc,GAAG,6BAAqB;AAC1CC,MAAAA,QAAQ,EAAEF,GADgC;AAE1CG,MAAAA,cAAc,EAAEC,KAAK,IAAI;AAGvB9D,QAAAA,OAAO,CAAC+D,cAAR,CAAuBD,KAAvB,EAA8B,UAA9B,EAA0C;AAACE,UAAAA,KAAK,EAAE,MAAM;AAAd,SAA1C;AACA,eAAOC,0BAAiBC,YAAjB,CAA8BJ,KAA9B,CAAP;AACD;AAPyC,KAArB,CAAvB;;AAUA,QAAI,CAACH,cAAL,EAAqB;AACnB,YAAM,IAAI/F,KAAJ,CAAW,oDAAmD8F,GAAG,CAACxB,OAAQ,GAA1E,CAAN;AACD;;AAED,WAAOyB,cAAc,CAACQ,UAAf,CAA0B;AAC/BC,MAAAA,KAAK,EAAE;AADwB,KAA1B,CAAP;AAGD,GAlBD;;AAqBApI,EAAAA,GAAG,CAACqI,WAAJ,GAAkBC,cAAlB;AAGAtI,EAAAA,GAAG,CAACuI,iBAAJ,GAAwBC,oBAAxB;AAGAxI,EAAAA,GAAG,CAACyI,aAAJ,GAAoBC,gBAApB;AAMA1I,EAAAA,GAAG,CAACyE,SAAJ,CAAc1E,WAAd;AAGA,SAAOC,GAAP;AACD","sourcesContent":["import os from 'os';\nimport util from 'util';\nimport {Writable} from 'stream';\n\nimport env from '@darkobits/env';\nimport mask from '@darkobits/mask-string';\nimport sleep from '@darkobits/sleep';\nimport stripIndent from 'strip-indent';\nimport chalk from 'chalk';\nimport createCallsiteRecord from 'callsite-record';\nimport * as dateFns from 'date-fns';\nimport merge from 'deepmerge';\nimport IS_CI from 'is-ci';\nimport { isPlainObject } from 'is-plain-object';\nimport ow from 'ow';\nimport sourceMapSupport from 'source-map-support';\n\nimport DEFAULT_CONFIG, { DEFAULT_STREAM } from 'etc/config';\nimport DEFAULT_STYLE from 'etc/style';\nimport {\n  DEFAULT_FRAME_RATE,\n  DEFAULT_LEVEL_OPTIONS,\n  IS_PREFIX\n} from 'etc/constants';\nimport {\n  BeginInteractiveOptions,\n  LevelDescriptor,\n  Logger,\n  LogOptions,\n  Primitive,\n  StyleFunction,\n  EndInteractiveFn,\n  EndInteractiveOptions\n} from 'etc/types';\nimport {\n  createOrphanedObject,\n  formatError\n} from 'lib/utils';\nimport LogHistoryFactory, {LogHistory} from 'lib/history';\nimport isDebugNamespace from 'lib/is-debug-namespace';\nimport LogPipe from 'lib/log-pipe';\nimport ProgressBarFactory from 'lib/progress-bar';\nimport SpinnerFactory from 'lib/spinner';\nimport TimerFactory from 'lib/timer';\n\n\n/**\n * Provided an options object, returns a logger instance.\n */\nexport default function LogFactory(userOptions: Partial<LogOptions> = {}) {\n  /**\n   * Logger instance.\n   */\n  const log = createOrphanedObject<Logger>();\n\n\n  /**\n   * @private\n   *\n   * Base configuration for the logger.\n   */\n  let options = merge<Required<Omit<LogOptions, 'stream'>>>(DEFAULT_CONFIG, DEFAULT_STYLE);\n\n\n  /**\n   * @private\n   *\n   * Secrets added via `#addSecret` that will be masked by the logger.\n   */\n  const secrets: Array<[Primitive | RegExp, string]> = [];\n\n\n  /**\n   * @private\n   *\n   * The current stream we are writing to. This can be set to `false` to disable\n   * writing.\n   */\n  let stream: NodeJS.WritableStream | false;\n\n\n  /**\n   * @private\n   *\n   * The logger's history ledger.\n   */\n  let history: LogHistory;\n\n\n  // ----- Private Methods -----------------------------------------------------\n\n  /**\n   * @private\n   *\n   * Provided a log line, returns a new log line with each secret known to\n   * the logger masked.\n   */\n  const maskSecretsInLine = (line: string) => {\n    return secrets.reduce<string>((messageAccumulator, [curSecret, curMaskChar]) => {\n      return mask(String(curSecret), messageAccumulator, curMaskChar);\n    }, line);\n  };\n\n\n  /**\n   * @private\n   *\n   * Provided a log line, writes the line's content to our output stream after\n   * masking any secrets contained therein.\n   */\n  const outputLogLine = (logLine: string) => {\n    history.write(maskSecretsInLine(`${logLine}${os.EOL}`));\n  };\n\n\n  /**\n   * @private\n   *\n   * Provided a token and a function, invokes the function with the token and\n   * the logger's Chalk instance and returns the result.\n   */\n  const styleToken = (token: Primitive | undefined, styleFn: StyleFunction | undefined) => {\n    if (token === undefined) {\n      return;\n    }\n\n    if (typeof styleFn !== 'function') {\n      return token;\n    }\n\n    return styleFn(token as string, log.chalk);\n  };\n\n\n  /**\n   * @private\n   *\n   * Provided a single argument passed to a logging function, returns a\n   * serialized and formatted string representation of the argument.\n   */\n  const formatLogArgument = (arg: any) => {\n    // For strings, return the argument as-is.\n    if (typeof arg === 'string') {\n      if (options.stripIndent) {\n        return stripIndent(arg).trim();\n      }\n\n      return arg;\n    }\n\n    // For Errors, use `formatError`.\n    if (arg instanceof Error) {\n      return formatError(log.chalk, arg);\n    }\n\n    // For all other arguments, use `util.inspect`.\n    return util.inspect(arg, {colors: true, depth: 20});\n  };\n\n\n  /**\n   * @private\n   *\n   * Provided a log level and an arbitrary number of arguments, returns an array\n   * of strings representing individual lines that should be written to the\n   * logger's output stream.\n   *\n   * This function is responsible for rendering any headings, prefixes, styles,\n   * and applying serialization techniques to arguments.\n   */\n  const convertArgumentsToLines = (level: string, ...args: Array<any>) => {\n    const {heading, levels, style, timestamp} = options;\n\n    ow(levels, 'levels', ow.object.plain);\n    ow(style, 'style', ow.object.plain);\n\n    let prefix = '';\n\n    const lines = args.map(arg => {\n      // If the current argument was produced by invoking log.prefix(), assign\n      // it to `prefix` and return `false`, which will be filtered-out below.\n      if (arg?.[IS_PREFIX]) {\n        prefix = arg;\n        return false;\n      }\n\n      return formatLogArgument(arg);\n    }).filter(Boolean).join(' ').split(os.EOL);\n\n    // Build the lead for each line.\n    const lead = [\n      // Timestamp\n      timestamp ? styleToken(dateFns.format(new Date(), timestamp), style.timestamp) : false,\n      // Heading\n      styleToken(heading, style.heading),\n      // Level\n      styleToken(levels[level].label, levels[level].style),\n      // Prefix\n      prefix\n    ].filter(Boolean).join(' ');\n\n    // Apply lead and prefix, then return an array of finalized lines.\n    return lines.map(line => `${lead} ${line}`);\n  };\n\n\n  /**\n   * @private\n   *\n   * Common logic for each logging method created with `addLevel`, where the\n   * only notable distinction is the level for the message.\n   */\n  const handleLogArguments = (level: string, ...args: Array<any>) => {\n    // No-op if the current level is insufficient to allow the incoming message\n    // to be logged.\n    if (!log.isLevelAtLeast(level)) {\n      return;\n    }\n\n    // Convert our array of arguments into an array of formatted log lines.\n    convertArgumentsToLines(level, ...args).forEach(logLine => {\n      // For each line, write to our history (taking note of whether the line\n      // was produced interactively or not) and write it to the logger's output\n      // stream.\n      outputLogLine(logLine);\n    });\n  };\n\n\n  /**\n   * @private\n   *\n   * Adds a new level (and logging method) to the logger.\n   */\n  const addLevel = (name: string, levelOptions: LevelDescriptor) => {\n    ow(levelOptions.label, 'label', ow.string);\n    ow(levelOptions.level, 'level', ow.number);\n\n    // Special-casing for the 'silent' level, which exists in the default log\n    // levels but should not have a corresponding log method.\n    if (name === 'silent') {\n      return;\n    }\n\n    // Add method for level.\n    Reflect.set(log, name, (...args: Array<any>) => {\n      handleLogArguments(name, ...args);\n    });\n  };\n\n\n  /**\n   * @private\n   *\n   * Common logic used by `startInteractive` and `stopInteractive` to handle\n   * producing one or more interactive log lines.\n   */\n  const handleInteractiveWrite = (sessionId: symbol, messageFn: any) => {\n    history.doInteractiveWrite(sessionId, messageFn);\n  };\n\n\n  // ----- Public Methods ------------------------------------------------------\n\n  /**\n   * N.B. These methods get their type definitions by virtue of being attached\n   * to the log object.\n   *\n   * See: types.ts\n   */\n\n  log.getLevel = () => {\n    const {level, levels} = options;\n    return {...levels[level]} as LevelDescriptor;\n  };\n\n\n  log.getLevels = () => {\n    const {levels} = options;\n\n    return levels as {\n      [key: string]: LevelDescriptor;\n    };\n  };\n\n\n  log.isLevelAtLeast = name => {\n    const {levels} = options;\n\n    const testLevel = levels[name] as LevelDescriptor;\n\n    if (!testLevel) {\n      throw new Error(`Invalid log level: \"${name}\".`);\n    }\n\n    return log.getLevel().level >= testLevel.level;\n  };\n\n\n  log.configure = (newOptions = {}) => {\n    // Pluck the 'stream' option from our options object, as it does not play\n    // nice with deepmerge.\n    const streamFromOptions: NodeJS.WritableStream | false | undefined = Reflect.get(newOptions, 'stream');\n    Reflect.deleteProperty(newOptions, 'stream');\n\n    if (streamFromOptions !== undefined) {\n      // If an explicit value was provided in our options, always use it.\n      stream = streamFromOptions;\n    } else if (stream === undefined) {\n      // Otherwise, if the stream has not been set yet, set it to the default\n      // stream.\n      stream = DEFAULT_STREAM;\n    }\n\n    options = merge<Required<Omit<LogOptions, 'stream'>>>(options, newOptions, {\n      isMergeableObject: isPlainObject\n    });\n\n    ow(stream, 'stream', ow.any(ow.undefined, ow.object.instanceOf(Writable), ow.boolean.false));\n    ow(options.levels, 'levels', ow.object.plain);\n\n    // Set the log level.\n    if (options.heading && isDebugNamespace(options.heading)) {\n      options.level = 'silly';\n    } else {\n      options.level = env('LOG_LEVEL') ?? options.level ?? 'info';\n    }\n\n    if (!log.chalk) {\n      // Create a custom Chalk instance for the logger using the provided\n      // options.\n      log.chalk = new chalk.Instance(options.chalk);\n    }\n\n    if (!history) {\n      // Initialize a LogHistory.\n      history = LogHistoryFactory({stream});\n    } else {\n      // Update stream.\n      history.setStream(stream);\n    }\n\n    // Update log level methods.\n    Object.entries(options.levels).forEach(([name, descriptor]) => {\n      if (!Reflect.has(log, name)) {\n        addLevel(name, merge(DEFAULT_LEVEL_OPTIONS, descriptor || {}));\n      }\n    });\n  };\n\n\n  log.prefix = prefix => {\n    let formattedPrefix = prefix;\n    const {style} = options;\n\n    if (style.prefix) {\n      formattedPrefix = styleToken(prefix, style.prefix) ?? prefix;\n    }\n\n    return {\n      [IS_PREFIX]: true,\n      toString: () => formattedPrefix.toString()\n    };\n  };\n\n\n  log.beginInteractive = userInteractiveOptions => {\n    const interactiveOptions: Required<BeginInteractiveOptions> = typeof userInteractiveOptions === 'function'\n      ? { message: userInteractiveOptions, interval: DEFAULT_FRAME_RATE }\n      : merge<Required<BeginInteractiveOptions>>(\n        { interval: DEFAULT_FRAME_RATE },\n        userInteractiveOptions\n      );\n\n    const sessionId = history.beginInteractiveSession();\n\n    const endInteractiveSession: EndInteractiveFn = userStopOptions => {\n      let stopOptions: Partial<EndInteractiveOptions> = {};\n\n      // Merge and validate options.\n      if (typeof userStopOptions === 'function') {\n        stopOptions = {\n          message: userStopOptions\n        };\n      } else if (userStopOptions) {\n        stopOptions = userStopOptions;\n      }\n\n      // If we're in a CI environment, call the provided callback once and then\n      // bail.\n      if (IS_CI && typeof stopOptions.message === 'function') {\n        stopOptions.message();\n        return;\n      }\n\n      if (stopOptions && typeof stopOptions.message === 'function') {\n        handleInteractiveWrite(sessionId, stopOptions.message);\n      }\n\n      history.endInteractiveSession(sessionId);\n    };\n\n    // If we're in a CI environment, call the provided callback once and then\n    // bail.\n    if (IS_CI) {\n      interactiveOptions.message();\n      return endInteractiveSession;\n    }\n\n    ow(interactiveOptions.message, 'message', ow.function);\n    ow(interactiveOptions.interval, 'interval', ow.number.positive);\n\n    const interactiveLoop = async () => {\n      while (history.hasInteractiveSession(sessionId)) {\n        handleInteractiveWrite(sessionId, interactiveOptions.message);\n        await sleep(interactiveOptions.interval);\n      }\n    };\n\n    void interactiveLoop();\n\n    return endInteractiveSession;\n  };\n\n\n  log.addSecret = (secret, maskChar = '*') => {\n    ow(secret, 'secret', ow.any(ow.string, ow.number, ow.boolean, ow.regExp));\n    ow(maskChar, 'mask character', ow.string.minLength(1).maxLength(1));\n    secrets.push([secret, maskChar]);\n  };\n\n\n  log.createPipe = level => {\n    // Validate log level.\n    if (!Object.keys(log.getLevels()).includes(level)) {\n      throw new Error(`Invalid log level: ${level}`);\n    }\n\n    // @ts-ignore\n    return new LogPipe(log[level]);\n  };\n\n\n  log.codeFrame = err => {\n    const callsiteRecord = createCallsiteRecord({\n      forError: err,\n      processFrameFn: frame => {\n        // Avoid `frame.isNative is not a function` errors. This also needs to\n        // return `false` to ensure frames are rendered using source maps.\n        Reflect.defineProperty(frame, 'isNative', {value: () => false});\n        return sourceMapSupport.wrapCallSite(frame);\n      }\n    });\n\n    if (!callsiteRecord) {\n      throw new Error(`Unable to produce a call site record for error: \"${err.message}\"`);\n    }\n\n    return callsiteRecord.renderSync({\n      stack: false\n    });\n  };\n\n\n  log.createTimer = TimerFactory;\n\n\n  log.createProgressBar = ProgressBarFactory;\n\n\n  log.createSpinner = SpinnerFactory;\n\n\n  // ----- Init ----------------------------------------------------------------\n\n  // Apply user-provided options.\n  log.configure(userOptions);\n\n\n  return log;\n}\n"],"file":"log.js"}