{"version":3,"sources":["../../src/lib/history.ts"],"names":["streamHistories","Map","interactiveSessionIdCounter","LogHistoryFactory","opts","logHistory","interactiveWriteId","streamHandle","lastEntryIsCompleteLine","history","length","lastItemContent","content","endsWith","os","EOL","updateHistory","interactiveSessionId","lineContent","interactiveSessionIds","matches","RegExp","exec","Error","pop","forEach","push","lastEntry","slice","decorateOutputStream","stream","args","cb","originalWrite","write","bind","chunk","Buffer","from","toString","Reflect","apply","getFirstInteractiveIndex","id","findIndex","logLine","undefined","setStream","newStream","has","set","get","beginInteractiveSession","Symbol","endInteractiveSession","ow","symbol","includes","map","filter","curId","hasInteractiveSession","doInteractiveWrite","function","ansiEscapes","cursorHide","firstInteractiveIndex","oldStreamHistory","truncatedLines","cursorUp","historicalIndex","truncatedLine","oldLine","eraseLine","cursorDown","cursorShow","string"],"mappings":"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","sourcesContent":["/**\n * ===== Log History ===========================================================\n *\n * This module provides an API that facilitates writing to a stream where we may\n * want to periodically re-write one or more lines to facilitate interactivity\n * (eg: progress bars). A log history instance may have multiple interactive\n * sessions in progress at the same time.\n */\nimport os from 'os';\nimport ansiEscapes from 'ansi-escapes';\nimport ow from 'ow';\nimport stripAnsi from 'strip-ansi';\nimport {createOrphanedObject} from 'lib/utils';\n\n\n// ----- Private Globals -------------------------------------------------------\n\n/**\n * @private\n *\n * Singleton map of streams to stream descriptors. This ensures that we do not\n * decorate streams more than once, and that multiple LogHistory instances that\n * are configured with the same output stream will use the same history.\n */\nconst streamHistories = new Map<NodeJS.WritableStream | false, StreamHandle>();\n\n\n/**\n * @private\n *\n * Counter used when creating Symbols for interactive session IDs. Mostly useful\n * for debugging purposes.\n */\nlet interactiveSessionIdCounter = 0;\n\n\n// ----- Types -----------------------------------------------------------------\n\n/**\n * Object containing a Symbol that correlates a log line to its interactive\n * session, or `false` if the line was not produced via an interactive session,\n * and the line's content.\n */\nexport interface LogLine {\n  interactiveSessionId: symbol | false;\n  content: string;\n}\n\n\n/**\n * Represents the value stored in the streamHandles Map, which is an object\n * containing each stream's original `write` method and an array of LogLines\n * written to it.\n */\nexport interface StreamHandle {\n  originalWrite: (...args: Array<any>) => any;\n  history: Array<LogLine>;\n  interactiveSessionIds: Array<symbol>;\n}\n\n\n/**\n * Options object accepted by LogHistoryFactory.\n */\nexport interface LogHistoryOptions {\n  stream: NodeJS.WritableStream | false;\n}\n\n\n/**\n * Object returned by LogHistoryFactory.\n */\nexport interface LogHistory {\n  /**\n   * Update the stream that the ledger writes to.\n   */\n  setStream(newStream: NodeJS.WritableStream | false): void;\n\n  /**\n   * Begins a new interactive session and returns the Symbol representing the\n   * session ID.\n   */\n  beginInteractiveSession(): symbol;\n\n  /**\n   * Ends the LogHistory's interactive session.\n   */\n  endInteractiveSession(id: symbol): void;\n\n  /**\n   * Provided an interactive session ID, returns `true` if the provided\n   * interactive session ID matches the LogHistory's interactive session ID.\n   */\n  hasInteractiveSession(id: symbol): boolean;\n\n  /**\n   * For a LogHistory with an interactive session, begins an interactive write.\n   */\n  doInteractiveWrite(id: symbol, cb: () => void): void;\n\n  /**\n   * General purpose write method that consumers of a LogHistory instance should\n   * use in lieu of the write method of the output stream used to construct the\n   * LogHistory instance.\n   */\n  write(content: string): void;\n}\n\n\n// ----- Log History -----------------------------------------------------------\n\nexport default function LogHistoryFactory(opts: LogHistoryOptions) {\n  /**\n   * Log history instance.\n   */\n  const logHistory = createOrphanedObject<LogHistory>();\n\n  /**\n   * @private\n   *\n   * Tracks whether a write to the logger during an interactive session is\n   * a standard write or an interactive write.\n   */\n  let interactiveWriteId: symbol | false = false;\n\n\n  /**\n   * @private\n   *\n   * Object containing the un-decorated write method and history for our output\n   * stream.\n   */\n  let streamHandle: StreamHandle;\n\n\n  // ----- Private Methods -----------------------------------------------------\n\n  /**\n   * @private\n   *\n   * Returns `true` if the last entry in the history array ends with an EOL\n   * character.\n   */\n  const lastEntryIsCompleteLine = () => {\n    if (streamHandle.history.length === 0) {\n      return true;\n    }\n\n    const lastItemContent = streamHandle.history[streamHandle.history.length - 1].content;\n    return stripAnsi(lastItemContent).endsWith(os.EOL);\n  };\n\n\n  /**\n   * @private\n   *\n   * Responsible for accepting an incoming string that was written to the logger\n   * and writing each individual line to our history array as a LogLine tuple\n   * with the correct interactive session ID.\n   */\n  const updateHistory = (interactiveSessionId: symbol | false, lineContent: string) => {\n    // If there are no ongoing interactive sessions, we do not need to write\n    // anything to our history.\n    if (streamHandle.interactiveSessionIds.length === 0) {\n      return;\n    }\n\n    // Split the incoming string to separate lines.\n    // const matches = lineContent.match();\n    const matches = new RegExp(`.*(\\\\${os.EOL})?`, 'g').exec(lineContent);\n\n    if (!matches) {\n      throw new Error('Unexpected Error: Unable to split content into lines.');\n    }\n\n    // If the last character in `content` is not an EOL, we can get a stray ''.\n    // If so, remove it from the list of matches.\n    if (matches[matches.length - 1] === '') {\n      matches.pop();\n    }\n\n    matches.forEach(content => {\n      if (lastEntryIsCompleteLine()) {\n        streamHandle.history.push({interactiveSessionId, content});\n      } else {\n        const lastEntry = streamHandle.history.slice(-1)[0];\n        lastEntry.content = `${lastEntry.content}${content}`;\n      }\n    });\n  };\n\n\n  /**\n   * @private\n   *\n   * Decorates the `write` method of the configured writable stream such that\n   * any writes thereto will be captured in our history.\n   */\n  const decorateOutputStream = (stream: NodeJS.WritableStream | false) => {\n    if (stream === false) {\n      return (...args: Array<any>) => {\n        const cb = args.pop();\n        cb();\n        return true;\n      };\n    }\n\n    const originalWrite = stream.write.bind(stream);\n\n    // @ts-ignore\n    stream.write = (chunk: any, cb?: ((err?: Error | null | undefined) => void)) => {\n      updateHistory(false, Buffer.from(chunk).toString('utf8'));\n      return Reflect.apply(originalWrite, stream, [chunk, cb]);\n    };\n\n    return originalWrite;\n  };\n\n\n  /**\n   * @private\n   *\n   * Returns the index of the first interactive log line with an ID matching the\n   * provided ID. If no ID is provided, returns the first interactive log line.\n   */\n  const getFirstInteractiveIndex = (id?: symbol) => {\n    return streamHandle.history.findIndex(logLine => {\n      if (id === undefined) {\n        return logLine.interactiveSessionId !== false;\n      }\n\n      return logLine.interactiveSessionId === id;\n    });\n  };\n\n\n  // ----- Public Methods ------------------------------------------------------\n\n  logHistory.setStream = newStream => {\n    if (!streamHistories.has(newStream)) {\n      const originalWrite = decorateOutputStream(newStream);\n      streamHistories.set(newStream, {\n        originalWrite,\n        history: [],\n        interactiveSessionIds: []\n      });\n    }\n\n    // @ts-ignore\n    streamHandle = streamHistories.get(newStream);\n  };\n\n\n  logHistory.beginInteractiveSession = () => {\n    const interactiveSessionId = Symbol(`${++interactiveSessionIdCounter}`);\n    streamHandle.interactiveSessionIds.push(interactiveSessionId);\n    return interactiveSessionId;\n  };\n\n\n  logHistory.endInteractiveSession = id => {\n    ow(id, 'id', ow.symbol);\n\n    if (!streamHandle.interactiveSessionIds.includes(id)) {\n      throw new Error('Unknown interactive session ID.');\n    }\n\n    // At the end of an interactive session, mark all lines in our history\n    // related to the current session as non-interactive.\n    streamHandle.history = streamHandle.history.map(({interactiveSessionId, content}) => ({\n      interactiveSessionId: interactiveSessionId === id ? false : interactiveSessionId,\n      content\n    }));\n\n\n    // Remove the provided ID from our list of interactive session IDs.\n    streamHandle.interactiveSessionIds = streamHandle.interactiveSessionIds.filter(curId => curId !== id);\n\n    // If we are ending the last outstanding interactive session, we can safely\n    // truncate our history array.\n    if (streamHandle.interactiveSessionIds.length === 0) {\n      streamHandle.history = [];\n    }\n  };\n\n\n  logHistory.hasInteractiveSession = id => {\n    ow(id, 'id', ow.symbol);\n    return streamHandle.interactiveSessionIds.includes(id);\n  };\n\n\n  logHistory.doInteractiveWrite = (id, cb) => {\n    ow(id, 'id', ow.symbol);\n    ow(cb, 'callback', ow.function);\n\n    // Ensure we were provided a valid/known interactive session ID.\n    if (!streamHandle.interactiveSessionIds.includes(id)) {\n      throw new Error('Unknown interactive session ID.');\n    }\n\n    // Ensures that only 1 interactive write is active at a time.\n    if (interactiveWriteId) {\n      throw new Error('Only 1 interactive write allowed at a time.');\n    }\n\n    interactiveWriteId = id;\n    streamHandle.originalWrite(ansiEscapes.cursorHide);\n\n    // Find the index of the first LogLine in our history that matches the\n    // provided interactive session ID.\n    const firstInteractiveIndex = getFirstInteractiveIndex(id);\n\n    // This array will hold the state of the history array prior to the\n    // re-write. We will use it to determine which truncated lines need to be\n    // erased and re-written following the interactive re-write.\n    let oldStreamHistory: Array<LogLine> = [];\n\n    // This array will hold all truncated log lines that will need to be\n    // re-written to the canonical history, and possibly to the output stream\n    // (if they changed) following the interactive re-write.\n    let truncatedLines: Array<LogLine> = [];\n\n    if (firstInteractiveIndex !== -1) {\n      // Capture the current state of the stream history prior to performing the\n      // re-write.\n      oldStreamHistory = streamHandle.history;\n\n      // If we found a line matching the provided session ID, gather a list of\n      // all lines after it that do not match the provided ID. These lines will\n      // be erased, and we will need to re-write them to the output stream after\n      // the interactive write.\n      truncatedLines = streamHandle.history.slice(firstInteractiveIndex).filter(logLine => logLine.interactiveSessionId !== id);\n\n      // Reset the canonical stream history by deleting entries back to (and\n      // including) the interactive line(s) that is to be re-written.\n      streamHandle.history = streamHandle.history.slice(0, firstInteractiveIndex);\n\n      // Move the cursor back to the first interactive line that we need to\n      // re-write.\n      streamHandle.originalWrite(ansiEscapes.cursorUp(oldStreamHistory.length - firstInteractiveIndex));\n    }\n\n    // Invoke the provided callback, which should perform the write operation by\n    // calling our #write method. This will also append the new interactive\n    // lines to our history _and_ write them to our stream.\n    cb();\n\n    if (truncatedLines.length > 0) {\n      // Create an index we will use in our pre-rewrite history array that\n      // points to the line that lies where the cursor is positioned now; just\n      // below the last line that was produced during the interactive re-write.\n      let historicalIndex = firstInteractiveIndex + streamHandle.history.length;\n\n      // For each line in our truncated lines list, compare the truncated line\n      // to the line in our pre-rewrite history. If they match, we do not need\n      // to re-write the line in our output stream, and can simply re-add it to\n      // the canonical history and move on to the next line. If they do not\n      // match, we need to erase the current line in the output stream and\n      // replace it with the truncated line.\n      for (const truncatedLine of truncatedLines) { // tslint:disable-line prefer-for-of\n        const oldLine = oldStreamHistory[historicalIndex];\n\n        if (!oldLine || oldLine !== truncatedLine) {\n          streamHandle.originalWrite(ansiEscapes.eraseLine);\n          streamHandle.originalWrite(truncatedLine.content);\n        } else {\n          streamHandle.originalWrite(ansiEscapes.cursorDown(1));\n        }\n\n        streamHandle.history.push(truncatedLine);\n        ++historicalIndex;\n      }\n    }\n\n    interactiveWriteId = false;\n    streamHandle.originalWrite(ansiEscapes.cursorShow);\n  };\n\n\n  logHistory.write = content => {\n    ow(content, 'content', ow.string);\n    updateHistory(interactiveWriteId, content);\n\n    if (interactiveWriteId) {\n      streamHandle.originalWrite(ansiEscapes.eraseLine);\n    }\n\n    streamHandle.originalWrite(content);\n  };\n\n\n  // ----- Init ----------------------------------------------------------------\n\n  logHistory.setStream(opts.stream);\n\n  return logHistory;\n}\n"],"file":"history.js"}