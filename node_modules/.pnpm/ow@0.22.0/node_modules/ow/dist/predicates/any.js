"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnyPredicate = void 0;
const argument_error_1 = require("../argument-error");
const base_predicate_1 = require("./base-predicate");
const generate_argument_error_message_1 = require("../utils/generate-argument-error-message");
/**
@hidden
*/
class AnyPredicate {
    constructor(predicates, options = {}) {
        Object.defineProperty(this, "predicates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: predicates
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
    }
    [base_predicate_1.testSymbol](value, main, label, stack) {
        const errors = new Map();
        for (const predicate of this.predicates) {
            try {
                main(value, label, predicate, stack);
                return;
            }
            catch (error) {
                if (value === undefined && this.options.optional === true) {
                    return;
                }
                // If we received an ArgumentError, then..
                if (error instanceof argument_error_1.ArgumentError) {
                    // Iterate through every error reported.
                    for (const [key, value] of error.validationErrors.entries()) {
                        // Get the current errors set, if any.
                        const alreadyPresent = errors.get(key);
                        // If they are present already, create a unique set with both current and new values.
                        if (alreadyPresent) {
                            errors.set(key, [...new Set([...alreadyPresent, ...value])]);
                        }
                        else {
                            // Add the errors found as is to the map.
                            errors.set(key, value);
                        }
                    }
                }
            }
        }
        if (errors.size > 0) {
            // Generate the `error.message` property.
            const message = generate_argument_error_message_1.generateArgumentErrorMessage(errors, true);
            throw new argument_error_1.ArgumentError(`Any predicate failed with the following errors:\n${message}`, main, stack, errors);
        }
    }
}
exports.AnyPredicate = AnyPredicate;
