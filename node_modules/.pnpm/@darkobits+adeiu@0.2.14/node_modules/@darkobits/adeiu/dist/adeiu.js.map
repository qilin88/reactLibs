{"version":3,"sources":["../src/adeiu.ts"],"names":["SIGNALS","signalCallbacks","Map","writeErrorToStderr","cb","signal","err","stack","errType","constructor","name","cbName","stackLines","split","chalk","red","message","process","stderr","write","join","handler","callbacksForSignal","get","length","Error","results","Promise","all","map","includes","exit","kill","pid","adeiu","signals","ow","array","ofType","string","finalSignals","forEach","set","prependOnceListener","off","filter","curCallback"],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport ow from 'ow';\n\n\n/**\n * Signature of callbacks provided to `adeiu`.\n */\nexport type AdeiuCallback = (signal: NodeJS.Signals) => void | Promise<void>;\n\n\n/**\n * Optional options object that may be passed to `adeiu`.\n */\nexport interface AdeiuOptions {\n  /**\n   * (Optional) Array of signals that the provided callback should be invoked\n   * for. These signals are _not_ merged with the defaults, so each desired\n   * signal must be explicitly enumerated.\n   */\n  signals?: Array<NodeJS.Signals>;\n}\n\n\n/**\n * List of default POSIX signals to register handlers for.\n */\nexport const SIGNALS: Array<NodeJS.Signals> = [\n  'SIGINT',\n  'SIGQUIT',\n  'SIGTERM',\n  'SIGUSR2'\n];\n\n\n/**\n * Tracks which signals we have registered process listeners for, and which user\n * callbacks should be invoked for each signal.\n */\nconst signalCallbacks = new Map<NodeJS.Signals, Array<AdeiuCallback>>();\n\n\n/**\n * Provided an `adeiu` callback and an error it threw, logs the error to\n * stderr.\n *\n * @example\n *\n * const myCallback = () => {\n *   throw new TypeError('Oh noes!');\n * };\n *\n * ```\n * Error: [adeiu] SIGINT handler `myCallback` threw: TypeError: Oh noes!\n *   at myCallback (foo.js:42:3)\n * ```\n */\nfunction writeErrorToStderr(cb: AdeiuCallback, signal: NodeJS.Signals, err?: Error) {\n  if (err?.stack) {\n    const errType = err.constructor ? err.constructor.name : 'Error';\n    const cbName = cb.name ? `${signal} handler  \\`${cb.name}\\`` : 'Anonymous callback';\n    const stackLines = err.stack.split('\\n');\n    stackLines[0] = `${chalk.red(`Error: [adeiu] ${cbName} threw:`)} ${errType}: ${err.message}`;\n    process.stderr.write(`${stackLines.join('\\n')}\\n`);\n  }\n}\n\n\n/**\n * Common signal handler; concurrently calls each callback registered for the\n * provided signal. If any callbacks throw or reject, the process will exit with\n * code 1.\n */\nasync function handler(signal: NodeJS.Signals) {\n  // Get an array of user callbacks we need to invoke for the provided signal.\n  const callbacksForSignal = signalCallbacks.get(signal);\n\n  // If this occurs, it means there is an error in our handler (un)installation\n  // logic.\n  if (!callbacksForSignal || callbacksForSignal.length === 0) {\n    throw new Error(`Unexpected error: Expected at least 1 callback for signal ${signal}, but found none.`);\n  }\n\n  // Map our array of functions into an array of promises that will resolve with\n  // `true` if the function returns/resolves and `false` if the function throws\n  // or rejects.\n  const results = await Promise.all(callbacksForSignal.map(async cb => {\n    try {\n      await cb(signal);\n      return true;\n    } catch (err) {\n      writeErrorToStderr(cb, signal, err);\n      return false;\n    }\n  }));\n\n  if (results.includes(false)) {\n    // If any functions threw/rejected, exit with code 1.\n    // eslint-disable-next-line unicorn/no-process-exit\n    process.exit(1);\n  } else {\n    // N.B. We use process.kill() here rather than process.exit() because it\n    // causes any potential Node debuggers that are attached to detach from the\n    // process so that it can cleanly exit.\n    process.kill(process.pid, signal);\n  }\n}\n\n\n/**\n * Provided a function, registers a callback with several common POSIX signals\n * that will invoke the function upon receipt of any of the signals.\n *\n * Returns a function that, when invoked, will unregister the callback.\n */\nexport default function adeiu(cb: AdeiuCallback, {signals = []}: AdeiuOptions = {}) {\n  // Validate options.\n  ow(signals, 'signals', ow.array.ofType(ow.string));\n\n  // If the user provided a custom list of signals, use it. Otherwise, use the\n  // default list.\n  const finalSignals = signals.length > 0 ? signals : SIGNALS;\n\n  finalSignals.forEach(signal => {\n    const callbacksForSignal = signalCallbacks.get(signal);\n\n    if (!callbacksForSignal || callbacksForSignal.length === 0) {\n      signalCallbacks.set(signal, [cb]);\n      // Since this is the first callback being registered for this signal,\n      // install our handler for it.\n      process.prependOnceListener(signal, handler as NodeJS.SignalsListener);\n    } else {\n      signalCallbacks.set(signal, [...callbacksForSignal, cb]);\n    }\n  });\n\n  return () => {\n    finalSignals.forEach(signal => {\n      const callbacksForSignal = signalCallbacks.get(signal);\n\n      if (!callbacksForSignal || callbacksForSignal.length === 0) {\n        // User may have alreay called this function previously.\n        return;\n      }\n\n      if (callbacksForSignal.length === 1 && callbacksForSignal[0] === cb) {\n        signalCallbacks.set(signal, []);\n        // This means we are un-registering the last remaining callback for this\n        // signal, so uninstall our handler for it.\n        process.off(signal, handler as NodeJS.SignalsListener);\n      } else {\n        signalCallbacks.set(signal, callbacksForSignal.filter(curCallback => curCallback !== cb));\n      }\n    });\n  };\n}\n"],"file":"adeiu.js"}