"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = adeiu;
exports.SIGNALS = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _ow = _interopRequireDefault(require("ow"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SIGNALS = ['SIGINT', 'SIGQUIT', 'SIGTERM', 'SIGUSR2'];
exports.SIGNALS = SIGNALS;
const signalCallbacks = new Map();

function writeErrorToStderr(cb, signal, err) {
  if (err !== null && err !== void 0 && err.stack) {
    const errType = err.constructor ? err.constructor.name : 'Error';
    const cbName = cb.name ? `${signal} handler  \`${cb.name}\`` : 'Anonymous callback';
    const stackLines = err.stack.split('\n');
    stackLines[0] = `${_chalk.default.red(`Error: [adeiu] ${cbName} threw:`)} ${errType}: ${err.message}`;
    process.stderr.write(`${stackLines.join('\n')}\n`);
  }
}

async function handler(signal) {
  const callbacksForSignal = signalCallbacks.get(signal);

  if (!callbacksForSignal || callbacksForSignal.length === 0) {
    throw new Error(`Unexpected error: Expected at least 1 callback for signal ${signal}, but found none.`);
  }

  const results = await Promise.all(callbacksForSignal.map(async cb => {
    try {
      await cb(signal);
      return true;
    } catch (err) {
      writeErrorToStderr(cb, signal, err);
      return false;
    }
  }));

  if (results.includes(false)) {
    process.exit(1);
  } else {
    process.kill(process.pid, signal);
  }
}

function adeiu(cb, {
  signals = []
} = {}) {
  (0, _ow.default)(signals, 'signals', _ow.default.array.ofType(_ow.default.string));
  const finalSignals = signals.length > 0 ? signals : SIGNALS;
  finalSignals.forEach(signal => {
    const callbacksForSignal = signalCallbacks.get(signal);

    if (!callbacksForSignal || callbacksForSignal.length === 0) {
      signalCallbacks.set(signal, [cb]);
      process.prependOnceListener(signal, handler);
    } else {
      signalCallbacks.set(signal, [...callbacksForSignal, cb]);
    }
  });
  return () => {
    finalSignals.forEach(signal => {
      const callbacksForSignal = signalCallbacks.get(signal);

      if (!callbacksForSignal || callbacksForSignal.length === 0) {
        return;
      }

      if (callbacksForSignal.length === 1 && callbacksForSignal[0] === cb) {
        signalCallbacks.set(signal, []);
        process.off(signal, handler);
      } else {
        signalCallbacks.set(signal, callbacksForSignal.filter(curCallback => curCallback !== cb));
      }
    });
  };
}
//# sourceMappingURL=adeiu.js.map