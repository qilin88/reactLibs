{"version":3,"sources":["../src/env.ts"],"names":["env","variableName","strict","TypeError","process","Reflect","has","Error","value","undefined","JSON","parse","eq","stringify"],"mappings":";;;;;;;AAoCA,MAAMA,GAAQ,GAAG,CAAUC,YAAV,EAAkDC,MAAM,GAAG,KAA3D,KAAqE;AAGpF,MAAI,OAAOD,YAAP,KAAwB,QAAxB,IAAoC,OAAOA,YAAP,KAAwB,QAAhE,EAA0E;AACxE,UAAM,IAAIE,SAAJ,CAAe,0EAAyE,OAAOF,YAAa,IAA5G,CAAN;AACD;;AAGD,MAAI,OAAOG,OAAP,KAAmB,WAAvB,EAAoC;AAClC,UAAM,IAAID,SAAJ,CAAc,wCAAd,CAAN;AACD;;AAGD,MAAI,OAAOC,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAID,SAAJ,CAAe,yDAAwD,OAAOC,OAAQ,IAAtF,CAAN;AACD;;AAGD,MAAI,CAACC,OAAO,CAACC,GAAR,CAAYF,OAAZ,EAAqB,KAArB,CAAL,EAAkC;AAChC,UAAM,IAAIG,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAGD,MAAI,OAAOH,OAAO,CAACJ,GAAf,KAAuB,QAA3B,EAAqC;AACnC,UAAM,IAAIG,SAAJ,CAAe,6DAA4D,OAAOC,OAAO,CAACJ,GAAI,IAA9F,CAAN;AACD;;AAED,QAAMQ,KAAK,GAAGJ,OAAO,CAACJ,GAAR,CAAYC,YAAZ,CAAd;;AAGA,MAAIC,MAAM,IAAIM,KAAK,KAAKC,SAAxB,EAAmC;AACjC,UAAM,IAAIF,KAAJ,CAAW,mBAAkBN,YAAa,2CAA1C,CAAN;AACD;;AAID,MAAIO,KAAK,KAAKC,SAAd,EAAyB;AACvB,WAAOD,KAAP;AACD;;AAED,MAAI;AAUF,WAAOE,IAAI,CAACC,KAAL,CAAWH,KAAX,CAAP;AACD,GAXD,CAWE,MAAM;AAKN,WAAOA,KAAP;AACD;AACF,CA1DD;;AA6DAR,GAAG,CAACM,GAAJ,GAAUL,YAAY,IAAI;AACxB,SAAOD,GAAG,CAACC,YAAD,CAAH,KAAsBQ,SAA7B;AACD,CAFD;;AAKAT,GAAG,CAACY,EAAJ,GAAS,CAACX,YAAD,EAAeO,KAAf,EAAsBN,MAAM,GAAG,KAA/B,KAAyC;AAChD,MAAI,OAAOM,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOE,IAAI,CAACG,SAAL,CAAeL,KAAf,MAA0BE,IAAI,CAACG,SAAL,CAAeb,GAAG,CAACC,YAAD,EAAeC,MAAf,CAAlB,CAAjC;AACD;;AAED,SAAOF,GAAG,CAACC,YAAD,EAAeC,MAAf,CAAH,KAA8BM,KAArC;AACD,CAND;;eASeR,G","sourcesContent":["export interface Env {\n  /**\n   * Accepts an environment variable name. Returns the parsed value of the\n   * variable, if it is set.\n   *\n   * Additionally accepts an optional `strict` argument that, when `true`, will\n   * cause env to throw if the provided variable does not exist in process.env.\n   */\n  <T = any>(variableName: string, strict: true): T;\n  <T = any>(variableName: string, strict?: boolean): T | undefined;\n\n  /**\n   * Returns `true` if the provided variable name is set and `false` otherwise.\n   *\n   * Shorthand for `Object.keys(process.env).includes(variableName)`.\n   */\n  has(variableName: string): boolean;\n\n  /**\n   * Accepts a variable name and a value and returns `true` if the variable name\n   * is strictly equal to the provided value.\n   *\n   * Additionally accepts an optional `strict` argument that, when `true`, will\n   * cause env.eq to throw if the provided variable does not exist in\n   * process.env.\n   *\n   * Note: When comparing against non-primitives (objects, arrays), env.eq will\n   * serialize the provided `value` and compare it against the serialized (re:\n   * string) form of the environment variable.\n   *\n   * Shorthand for `env('SOME_VAR') === testValue`.\n   */\n  eq(variableName: string, value: any, strict?: boolean): boolean;\n}\n\n\nconst env: Env = <T = any>(variableName: keyof typeof process.env, strict = false) => {\n  // Throw if first argument is not a string or a number. Although normal\n  // objects may have exotic key types (ie: Symbols) process.env may not.\n  if (typeof variableName !== 'string' && typeof variableName !== 'number') {\n    throw new TypeError(`[env] Expected first argument to be of type \"string\" or \"number\", got \"${typeof variableName}\".`);\n  }\n\n  // Throw if 'process' does not exist. (User might be in the browser.)\n  if (typeof process === 'undefined') {\n    throw new TypeError('[env] Global \"process\" does not exist.');\n  }\n\n  // Throw if process is a non-object.\n  if (typeof process !== 'object') {\n    throw new TypeError(`[env] Expected \"process\" to be of type \"object\", got \"${typeof process}\".`);\n  }\n\n  // Throw if process.env does not exist.\n  if (!Reflect.has(process, 'env')) {\n    throw new Error('[env] \"env\" does not exist in object \"process\".');\n  }\n\n  // Throw if process.env is a non-object.\n  if (typeof process.env !== 'object') {\n    throw new TypeError(`[env] Expected \"process.env\" to be of type \"object\", got \"${typeof process.env}\".`);\n  }\n\n  const value = process.env[variableName];\n\n  // Throw if in strict mode and the requested variable name does not exist.\n  if (strict && value === undefined) {\n    throw new Error(`[env] (Strict) \"${variableName}\" does not exist in object \"process.env\".`);\n  }\n\n  // This is primarily here to refine the type of `value` from\n  // `string | undefined` to `string`.\n  if (value === undefined) {\n    return value;\n  }\n\n  try {\n    /**\n     * If the requested variable is JSON-parse-able, parse it and return it.\n     *\n     * This will properly convert:\n     * - Number-like string values to numbers.\n     * - The string value 'true' to the boolean value `true`.\n     * - The string value 'false' to the boolean value `false`.\n     * - Any serialized data structure to its de-serialized value.\n     */\n    return JSON.parse(value) as T;\n  } catch {\n    /**\n     * If JSON.parse fails, return the value as-is. This will be the case for\n     * most string literal values.\n     */\n    return value as unknown as T;\n  }\n};\n\n\nenv.has = variableName => {\n  return env(variableName) !== undefined;\n};\n\n\nenv.eq = (variableName, value, strict = false) => {\n  if (typeof value === 'object') {\n    return JSON.stringify(value) === JSON.stringify(env(variableName, strict));\n  }\n\n  return env(variableName, strict) === value;\n};\n\n\nexport default env;\n"],"file":"env.js"}