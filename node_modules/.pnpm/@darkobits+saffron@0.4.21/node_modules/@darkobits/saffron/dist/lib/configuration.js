import path from "path";
import { cosmiconfig } from "cosmiconfig";
import merge from "deepmerge";
import fs from "fs-extra";
import { packageDirectory } from "pkg-dir";
import resolvePkg from "resolve-pkg";
import log from "./log.js";
import ow from "./ow.js";
import TypeScriptLoader from "./typescript-loader.js";

async function withBabelRegister(configPath, contents) {
  const pkgDir = await packageDirectory({
    cwd: path.dirname(configPath)
  });
  const babelRegisterPath = resolvePkg('@babel/register');
  const wrapper = `
    const babelRegister = require('${babelRegisterPath}');
    babelRegister({ extensions: ['.ts', '.js', '.mjs', '.cjs', '.json'] });
    ${contents}
  `;
  const tempDir = path.resolve(pkgDir, 'node_modules');
  const loaderPath = path.resolve(tempDir, '.loader.js');
  await fs.ensureDir(tempDir);
  await fs.writeFile(loaderPath, wrapper);
  const result = await import(loaderPath);
  await fs.remove(loaderPath);
  return result;
}

async function parseConfiguration(filepath) {
  const errorThunks = [];
  let lastErrorMessage;

  try {
    const config = await withBabelRegister(filepath, `
      module.exports = import("${filepath}?nonce=2").then(result => {
        return result?.default ? result.default : result;
      });
    `);
    log.verbose(log.prefix('parseConfiguration'), log.chalk.green.bold('Loaded configuration using @babel/register + import().'));
    return config !== null && config !== void 0 && config.default ? config.default : config;
  } catch (err) {
    errorThunks.push(() => log.silly(log.prefix('parseConfiguration'), log.chalk.red.bold('Failed to load configuration file with @babel/register + import():'), err.message));
    lastErrorMessage = err.message;
  }

  if (errorThunks.length > 0) {
    errorThunks.forEach(errorThunk => errorThunk());
  }

  if (lastErrorMessage) {
    throw new Error(`Error parsing configuration file: ${lastErrorMessage}`);
  }

  throw new Error('All configuration parsing strategies failed.');
}

export default async function loadConfiguration({
  fileName,
  key,
  searchFrom,
  ...cosmicOptions
}) {
  ow(fileName, 'fileName', ow.string.nonEmpty);
  ow(key, 'key', ow.optional.string);
  const configResult = await cosmiconfig(fileName, merge({
    loaders: {
      '.ts': TypeScriptLoader,
      '.js': parseConfiguration,
      '.mjs': parseConfiguration,
      '.cjs': parseConfiguration
    },
    searchPlaces: ['package.json', `.${fileName}.json`, `.${fileName}.yaml`, `.${fileName}.yml`, `.${fileName}rc`, `${fileName}.config.ts`, `${fileName}.config.js`, `${fileName}.config.cjs`, `${fileName}.config.mjs`, `${fileName}rc.ts`, `${fileName}rc.js`, `${fileName}rc.cjs`, `${fileName}rc.mjs`]
  }, cosmicOptions, {
    arrayMerge: (target, source) => {
      return [...source, ...target];
    }
  })).search(searchFrom);

  if (configResult && !configResult.isEmpty && key) {
    if (!Reflect.has(configResult.config, key)) {
      Reflect.deleteProperty(configResult, 'config');
      configResult.isEmpty = true;
    } else {
      configResult.config = configResult.config[key];
    }
  }

  if (configResult) {
    return configResult;
  }
}
//# sourceMappingURL=configuration.js.map