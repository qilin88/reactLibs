{"version":3,"sources":["../../src/lib/configuration.ts"],"names":["path","cosmiconfig","merge","fs","packageDirectory","resolvePkg","log","ow","TypeScriptLoader","withBabelRegister","configPath","contents","pkgDir","cwd","dirname","babelRegisterPath","wrapper","tempDir","resolve","loaderPath","ensureDir","writeFile","result","remove","parseConfiguration","filepath","errorThunks","lastErrorMessage","config","verbose","prefix","chalk","green","bold","default","err","push","silly","red","message","length","forEach","errorThunk","Error","loadConfiguration","fileName","key","searchFrom","cosmicOptions","string","nonEmpty","optional","configResult","loaders","searchPlaces","arrayMerge","target","source","search","isEmpty","Reflect","has","deleteProperty"],"mappings":"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","sourcesContent":["import path from 'path';\n\nimport { cosmiconfig } from 'cosmiconfig';\nimport merge, { } from 'deepmerge';\nimport fs from 'fs-extra';\nimport { packageDirectory } from 'pkg-dir';\nimport resolvePkg from 'resolve-pkg';\n\n\nimport { SaffronCosmiconfigOptions, SaffronCosmiconfigResult } from 'etc/types';\nimport log from 'lib/log';\nimport ow from 'lib/ow';\nimport TypeScriptLoader from 'lib/typescript-loader';\n\n\n/**\n * @private\n *\n * Creates a temporary module in the nearest node_modules folder that loads\n * @babel/register, executes the provided contents, and returns the result. The\n * node_modules folder is used to ensure Babel loads the nearest configuration\n * file.\n */\nasync function withBabelRegister(configPath: string, contents: string) {\n  const pkgDir = await packageDirectory({ cwd: path.dirname(configPath) });\n  const babelRegisterPath = resolvePkg('@babel/register');\n  const wrapper = `\n    const babelRegister = require('${babelRegisterPath}');\n    babelRegister({ extensions: ['.ts', '.js', '.mjs', '.cjs', '.json'] });\n    ${contents}\n  `;\n\n  const tempDir = path.resolve(pkgDir, 'node_modules');\n  const loaderPath = path.resolve(tempDir, '.loader.js');\n  await fs.ensureDir(tempDir);\n  await fs.writeFile(loaderPath, wrapper);\n  const result = await import(loaderPath);\n  await fs.remove(loaderPath);\n  return result;\n}\n\n\n/**\n * Cosmiconfig custom loader that supports ESM syntax and any Babel plugins that\n * may be installed in the local project. This function attempts 6 different\n * parsing strategies in sequence that should cover cases where we are in a CJS\n * context trying to load an ESM configuration file and vice versa.\n */\nasync function parseConfiguration(filepath: string) {\n  const errorThunks: Array<() => void> = [];\n  let lastErrorMessage: string;\n\n\n  // ----- Babel Register + Dynamic Import -------------------------------------\n\n  // This strategy will work when we are in a CJS or ESM context trying to load\n  // an ESM configuration file that uses (or requires files that use) certain\n  // Babel features or path mappings that are configured by the local project's\n  // Babel configuration file.\n  try {\n    const config = await withBabelRegister(filepath, `\n      module.exports = import(\"${filepath}?nonce=2\").then(result => {\n        return result?.default ? result.default : result;\n      });\n    `);\n    log.verbose(log.prefix('parseConfiguration'), log.chalk.green.bold('Loaded configuration using @babel/register + import().'));\n    return config?.default ? config.default : config;\n  } catch (err: any) {\n    errorThunks.push(\n      () => log.silly(\n        log.prefix('parseConfiguration'),\n        log.chalk.red.bold('Failed to load configuration file with @babel/register + import():'),\n        err.message\n      )\n    );\n    lastErrorMessage = err.message;\n  }\n\n\n  // ----- Error Reporting -----------------------------------------------------\n\n  if (errorThunks.length > 0) {\n    errorThunks.forEach(errorThunk => errorThunk());\n  }\n\n  if (lastErrorMessage) {\n    throw new Error(`Error parsing configuration file: ${lastErrorMessage}`);\n  }\n\n  throw new Error('All configuration parsing strategies failed.');\n}\n\n\n/**\n * Loads configuration from a configuration file using cosmiconfig. Supports\n * optional sub-key traversal.\n *\n * Note: Cosmiconfig caches every file it loads, so if multiple commands are\n * registered that use the same file, we don't have to worry about multiple\n * filesystem calls here.\n */\nexport default async function loadConfiguration<C>({ fileName, key, searchFrom, ...cosmicOptions }: SaffronCosmiconfigOptions) {\n  // Validate options.\n  ow(fileName, 'fileName', ow.string.nonEmpty);\n  ow(key, 'key', ow.optional.string);\n\n  const configResult = await cosmiconfig(fileName, merge({\n    loaders: {\n      '.ts': TypeScriptLoader,\n      '.js': parseConfiguration,\n      '.mjs': parseConfiguration,\n      '.cjs': parseConfiguration\n    },\n    searchPlaces: [\n      'package.json',\n      `.${fileName}.json`,\n      `.${fileName}.yaml`,\n      `.${fileName}.yml`,\n      `.${fileName}rc`,\n      `${fileName}.config.ts`,\n      `${fileName}.config.js`,\n      `${fileName}.config.cjs`,\n      `${fileName}.config.mjs`,\n      `${fileName}rc.ts`,\n      `${fileName}rc.js`,\n      `${fileName}rc.cjs`,\n      `${fileName}rc.mjs`\n    ]\n  }, cosmicOptions, {\n    arrayMerge: (target, source) => {\n      // When merging arrays (like searchPlaces) prepend the user's value to\n      // our value.\n      return [...source, ...target];\n    }\n  })).search(searchFrom);\n\n  // If we loaded a non-empty file and the user specified a sub-key that they\n  // want to drill-down into, ensure that the root configuration object has that\n  // key. If it doesn't, delete the 'config' property on our result and set\n  // 'isEmpty' to true. Otherwise, hoist the desired sub-key up to the root of\n  // the result.\n  if (configResult && !configResult.isEmpty && key) {\n    if (!Reflect.has(configResult.config, key)) {\n      Reflect.deleteProperty(configResult, 'config');\n      configResult.isEmpty = true;\n    } else {\n      configResult.config = configResult.config[key];\n    }\n  }\n\n  if (configResult) {\n    return configResult as SaffronCosmiconfigResult<C>;\n  }\n}\n"],"file":"configuration.js"}