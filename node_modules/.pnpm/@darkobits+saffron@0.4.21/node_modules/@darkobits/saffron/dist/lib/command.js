import camelcaseKeys from "camelcase-keys";
import loadConfiguration from "./configuration.js";
import ow from "./ow.js";
import getPackageInfo from "./package.js";
import yargs from "./yargs.js";
export default function buildCommand(options) {
  ow(options.command, 'command', ow.optional.string);
  ow(options.description, 'description', ow.optional.string);
  ow(options.builder, 'builder', ow.any(ow.undefined, ow.function));
  ow(options.handler, 'handler', ow.function);
  ow(options.strict, 'strict', ow.optional.boolean);
  ow(options.config, 'config', ow.any(ow.boolean.false, ow.object, ow.undefined));
  ow(options.aliases, 'aliases', ow.any(ow.undefined, ow.string, ow.array.ofType(ow.string)));
  const {
    pkgJson,
    pkgRoot
  } = getPackageInfo();

  const builder = command => {
    if (options.strict !== false) {
      command.strict();
    }

    command.showHelpOnFail(true, 'See --help for usage instructions.');
    command.wrap(yargs.terminalWidth());
    command.alias('v', 'version');
    command.alias('h', 'help');

    if (pkgJson !== null && pkgJson !== void 0 && pkgJson.version) {
      command.version(pkgJson.version);
    }

    command.help();

    if (options.builder) {
      options.builder({
        command,
        packageJson: pkgJson,
        packageRoot: pkgRoot
      });
    }

    return command;
  };

  const handler = async argv => {
    const handlerOpts = {};
    handlerOpts.argv = camelcaseKeys(argv, {
      deep: true
    });
    handlerOpts.packageJson = pkgJson;
    handlerOpts.packageRoot = pkgRoot;
    let autoConfig = false;

    if (options.config !== false) {
      var _options$config;

      autoConfig = ((_options$config = options.config) === null || _options$config === void 0 ? void 0 : _options$config.auto) !== false;
      const configResult = await loadConfiguration({
        fileName: pkgJson !== null && pkgJson !== void 0 && pkgJson.name ? pkgJson.name.split('/').slice(-1)[0] : undefined,
        ...options.config
      });

      if (configResult) {
        if (configResult.config) {
          handlerOpts.config = camelcaseKeys(configResult.config, {
            deep: true
          });
        }

        handlerOpts.configPath = configResult.filepath;
        handlerOpts.configIsEmpty = Boolean(configResult.isEmpty);

        if (autoConfig && !handlerOpts.configIsEmpty) {
          Object.entries(configResult.config).forEach(([key, value]) => {
            if (handlerOpts.argv && handlerOpts.config && Reflect.has(handlerOpts.argv, key)) {
              Reflect.set(handlerOpts.argv, key, value);
            }
          });
        }
      }
    }

    try {
      await options.handler(handlerOpts);
    } catch (err) {
      console.error(err);

      if (typeof (err === null || err === void 0 ? void 0 : err.exitCode) === 'number') {
        process.exit(err.exitCode);
      } else if (typeof (err === null || err === void 0 ? void 0 : err.code) === 'number') {
        process.exit(err.code);
      } else {
        process.exit(1);
      }
    }
  };

  yargs.command({
    command: options.command ?? '*',
    describe: (options === null || options === void 0 ? void 0 : options.description) ?? (pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.description) ?? undefined,
    aliases: options.aliases,
    builder,
    handler
  });
}
//# sourceMappingURL=command.js.map